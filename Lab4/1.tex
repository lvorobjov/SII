\chapter{Ход работы}

\section{Задание на лабораторную работу}

Разработать машину логического вывода, реализующую заданный метод
вывода и указанную стратегию поиска в пространстве состояний. В качестве
инструмента при создании интерпретатора правил использовать процедурный
язык программирования.

Вариант задания:
\begin{itemize}
    \item метод вывода --- обратный;
    \item алгоритм поиска --- в ширину;
    \item место расположения базы данных --- на диске;
    \item система программирования --- Си++.
\end{itemize}

\section{Описание стратегии логического вывода}

Обратный логический вывод --- вывод, при котором поиск доказательства цели начинается с целевого утверждения. Выясняются условия, при которых целевое утверждение является выводимым. Эти условия принимаются за новые текущие условия утверждения, и процесс поиска продолжается. Вывод заканчивается, когда все очередные условия оказываются аксиомами, или процесс безуспешен.

Алгоритм простого обратного логического вывода (описанный в ISBN 5-8459-0887-6, глава 9) показан на рисунке \ref{alg:fol-bc-ask}.

\begin{algorithm}[H]
\TitleOfAlgo{FOL-BC-Ask}
\KwIn{база знаний $KB$, запрос $goals$, текущая подстановка $\theta$ }
\KwData{\textit{answers}, текущее множество подстановок}
\lIf{список $goals$ пуст}{\KwRet{$\theta$}}
$q'$ --- результат подстановки $\theta$ в первый элемент списка $goals$\;
\ForEach{высказывание $r = (p_1,\,p_2,\,\ldots,\,p_n \rightarrow q)$ in $KB$, для которых выполнима подстановка $\theta'$, которая делает высказывание $q'$ и заключение $q$ правила $r$ идентичными}{
	добавить в множество $answers$ результат вызова FOL-BC-Ask с параметрами ($KB$, список предпосылок $p_i$ правила $r$ включая список $goals$ без первого элемента, композиция подстановок $\theta$ и $\theta'$)\;
}
\KwRet{$answers$}\;
\caption{Алгоритм простого обратного логического вывода} \label{alg:fol-bc-ask}
\end{algorithm}

Этот алгоритм представляет собой алгоритм поиска в глубину. Поэтому его потребности в пространстве напрямую зависят от размера доказательства.

Исходное состояние МЛВ --- список целей с одним элементом и пусой набор подстановок. На каждой итерации из базы знаний выираются все правила, голова которых сопоставима с первой целью из списка. Данная цель заменяется списком предпосылок найденного правила, а набор подстановок расширяется найденным правилом на даннной итерации. В конце алгоритма получаем список подстановок, который приводит к истинности основного заключения.

Для того, чтобы алгоритм обходил дерево в ширину, необходимо поменять порядок конкатенации списков целей. Такимо образом, вместо структуры LIFO получается структура FIFO для того, чтобы обрабатывать узлы дерева по уровням.

Дорожные знаки имеют 14 атрибутов, такие как цвет, форма, наличие стрелок и т.д. Для определения группы дорожного знака система запрашивает у пользователя ответы на вопросы, которые предоставляются механизмом обратного логического вывода.

\section{Основные структуры данных}

Структура атрибута имеет следующие поля:
\begin{enumerate}
    \item имя атрибута (например, цвет);
    \item перевод (например, цвет фона);
    \item подсказка (например, «Какого цвета фон дорожного знака?»);
    \item список возможных значений (например, «белый, красный, синий, зеленый, желтый»).
\end{enumerate}

Структура утверждения:
\begin{itemize}
    \item номер атрибута;
    \item значение атрибута.
\end{itemize}

Структура правила:
\begin{itemize}
    \item список утверждений: предпосылки;
    \item утверждение; заключение.
\end{itemize}

Элемент структуры стека целей:
\begin{itemize}
    \item номер атрибута;
    \item номер правила.
\end{itemize}

Элемент структуры стека контекстов:
\begin{itemize}
    \item номер атрибута;
    \item значение атрибута;
    \item номер правила.
\end{itemize}

\section{Алгоритм логического вывода на псевдокоде}

Основные этапы обратного логического вывода:
\begin{enumerate}
    \item Выбор правила бля оценки.
    
    Делается попытка найти в базе правил карточку с правилом, которое в заключении содержит атрибут текущей цели. Если такое правило найдено, то переходят к этапу оценки правила. В противном случае необходимо запросить помощь у пользователя (если есть подсказка для атрибута).
    
    \item Оценка правила.
    
    Требуется поочередно сопоставить утверждения из условной части правила с фактами ищ БФ. Возможны три следубщие ситуации:
    \begin{enumerate}
		\item Правило не поддается оценке (значение услоаной части правила \underline{неизвестно}), когда один из атрибутов условной части правила отсутствует в стеке контекстов БФ.
		
		Карточка с неизвестным атрибутом помещается в очередь целей вместе с карточной, содержащей неизвестное правило.
		
		Переход к этапу выбора правило для оценки.
		
		\item Правило считается \underline{ложным}, если одно из утверждений его условной части противоречит фактам в БФ. В этом случае карточку текущего правила помещают в колоду сброса, и возвращаются к этапу 1.
		
		Изъятие такого правила из БП ускоряем процесс обратного вывода.
		
		\item Правило считается \underline{истинным}, когда каждое утверждение его условной части согласуется с одним из фактов стека контекстов БФ.
		
		Текущая цель становится доказанной. Из истинности условной части делается вывод от истинности заключения, и порождается новый факт, который добавляется в стек контекстов БФ.
		
		Кроме того, из очереди целей извлекается карточка с доказанным правилом, и возвращается в колоду с правилами.
	\end{enumerate}
	
	\item Опрос пользователя. Если на этапе выбора правила не найдено правила для доказательства, то организуется диалог с пользователем для получения значения атрибута текущей цели.
\end{enumerate}



К примеру, выберем правила, доказывающие, что знак принадлежит к группе предупреждающих:
\begin{enumerate}[itemindent=0pt,label=\arabic*)]
	\item \begin{tabbing}
	\hspace{4em}\=\kill
	\bf ЕСЛИ \> \tabfill{Форма = Треугольник, вершина вверх} \\
	\bf ТО \> \tabfill{Группа = Предупреждающие знаки}
	\end{tabbing}

	\item \begin{tabbing}
	\hspace{4em}\=\kill
	\bf ЕСЛИ \> \tabfill{Форма = Прямоугольник} \\
	\bf И \> \tabfill{Цвет фона = Белый} \\
	\bf И \> \tabfill{Форма внутреннего знака = Нет знака} \\
	\bf И \> \tabfill{Характер текста = Отсутствует} \\
	\bf И \> \tabfill{Вид транспорта = Отсутствует} \\
	\bf И \> \tabfill{Тип зданий = Отсутствуют} \\
	\bf ТО \> \tabfill{Группа = Предупреждающие знаки}
	\end{tabbing}

	\item \begin{tabbing}
	\hspace{4em}\=\kill
	\bf ЕСЛИ \> \tabfill{Форма = Прямоугольник} \\
	\bf И \> \tabfill{Цвет фона = Красный} \\
	\bf ТО \> \tabfill{Группа = Предупреждающие знаки}
	\end{tabbing}

	\item \begin{tabbing}
	\hspace{4em}\=\kill
	\bf ЕСЛИ \> \tabfill{Форма = Буква Х} \\
	\bf ТО \> \tabfill{Группа = Предупреждающие знаки}
	\end{tabbing}
\end{enumerate}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\tikzset{level distance=40pt}
\tikzset{every leaf node/.style={text width=2cm,align=center,anchor=north}}	
\Tree [.{Знак является предупреждающим} [.\node[draw]{ИЛИ}; {Треугольная форма знака} [.\node[draw]{И}; {Прямоугольная форма} [.\node[draw]{ИЛИ}; {Красный фон} [.\node[draw]{И}; {Белый фон} {Нет внутреннего знака} {Нет текста, транспорта, зданий} ] ] ] {Форма буквы Х} ]  ]
\end{tikzpicture}
\caption{Дерево логического вывода для утверждения, что данный знак предупреждающий} \label{fig:tree-warnsign}
\end{figure}

обратный вывод --- это поиск пути на данном графе. Для подтверждения цели из всех связей ИЛИ выбирается одна, и делается попытка подтвердить все предпосылки этой цели. В случае неудачи выбирается следующая связь ИЛИ и т.д.

Возникает проблема разрешения конфликтов в узлах ИЛИ при логическом выводе, поскольку последовательность выбора правил и оценки его предпосылок влияет на число запросов к пользователю.

Различают несколько способов управления выводом (разрешения конфликтов), иначе, последовательности поиска на дереве логического вывода: поиск в глубину и в ширину.

Поиск в глубину --- при выборе очередной подцели в пространстве состояний предпочтение отдается той, которая соответствует более детальному описанию  задачи. Например, для дерева \ref{fig:tree-warnsign} последовательность запросов к пользователю будет следующая:
\begin{enumerate}
    \item форма знака --- прямоугольная?
    \item цвет фона --- белый?
    \item наличие внутреннего знака?
    \item наличие текста?
    \item наличие зданий?
    \item наличие транспорта?
    \item цвет фона --- красный?
    \item форма знака --- треугольная?
    \item форма знака --- буква Х?
\end{enumerate}

Поиск в ширину --- анализируются все подцели, нахоляющиеся на одном уровне пространства состояний и лишь потом переходят к подцелис ледубщего уровня деятельности. Например, последовательность запросов к пользователю будет следующая:
\begin{enumerate}
    \item форма знака --- треугольная?
    \item форма знака --- буква Х?
    \item форма знака --- прямоугольная?
    \item цвет фона --- красный?
    \item цвет фона --- белый?
    \item наличие внутреннего знака?
    \item наличие текста?
    \item наличие зданий?
    \item наличие транспорта?
\end{enumerate}

Порядок обхода дерева зависит от последовательности атрибутов в стеке целей.

Алгоритм обратного логического вывода на основе индексных карточек представлен на рисунке \ref{alg:fol_index}.

\begin{algorithm}[H]
\KwIn{база правил $KB$, глобальная цель, стек целей $goals$, стек контекстов $\theta $}
Поместить глобальную цель в стек целей\;
\Repeat{стек целей не пуст}{
	\eIf{$\exits r=(p_1,\ldots,p_n \leftarrow q) \in KB$, которое в $q$ содержит атрибут цели}{
		\ForEach{правило $r$ из $KB$, которое в заключении $q$ содержит атрибут текущей цели}{
			\uIf{$\exists p_i$, которое не содержится в $\theta$}{
				поместить $p_i$ в стек целей в порядке возрастания внутренних предпосылок\;
			} \uElseIf{$\exists p_i$, которое ложно}{
				изъять правило $r$ в состояние сброса\;
			} \Else{
				переместить текущую цель в $\theta$ с найденным атрибутом\;
				break\;
			} 
		}
	}{
		\eIf{$\exists $ подсказка для текущей цели}{
			показать подсказку\;
			получить ответ пользователя\;
			записать ответ в $\theta$\;
		}{
			поместить атрибут текущей цели в состояние сброса\;
		}
	} 
}
\caption{Алгоритм обратного логического вывода на основе индексных карточек} \label{alg:fol_index}
\end{algorithm}

\section{Текст программы}

\inputminted{c++}{src/logic.h}

\inputminted[firsthline=104,lastline=240]{c++}{src/logic.h}

\section{Моделирование логического вывода}

\input{trace.tex}

\section{Пример работы программы}

При запуске приложения выдерите текстовый файл, в котором содержит-
ся база продукционных правил. После этого шага появится первая страница
диалогового окна (рисунок \ref{fig:scr1}).

% Скриншоты \label{fig:scr*}

Система задает вопросы пользователю с помощью диалогового окна, со
списком выбора (рисунки \ref{fig:scr2} и \ref{fig:scr3}). Выбор ответа осуществляется с
помощью клавиатуры или мыши, после чего нажатием на кнопку Далее или
Enter происходит переход к следующему вопросу или показывается результат
(рисунок \ref{fig:scr4}).